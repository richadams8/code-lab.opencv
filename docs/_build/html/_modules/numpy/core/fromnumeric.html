<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>numpy.core.fromnumeric &mdash; code-lab.opencv 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="code-lab.opencv 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="numpy" href="../../numpy.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">code-lab.opencv 1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../numpy.html" accesskey="U">numpy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for numpy.core.fromnumeric</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Module containing non-deprecated functions borrowed from Numeric.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">VisibleDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">multiarray</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">umath</span> <span class="k">as</span> <span class="n">um</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">numerictypes</span> <span class="k">as</span> <span class="n">nt</span>
<span class="kn">from</span> <span class="nn">.numeric</span> <span class="kn">import</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_methods</span>

<span class="n">_dt_</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">sctype2char</span>


<span class="c"># functions that are methods</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;alen&#39;</span><span class="p">,</span> <span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="s">&#39;alltrue&#39;</span><span class="p">,</span> <span class="s">&#39;amax&#39;</span><span class="p">,</span> <span class="s">&#39;amin&#39;</span><span class="p">,</span> <span class="s">&#39;any&#39;</span><span class="p">,</span> <span class="s">&#39;argmax&#39;</span><span class="p">,</span>
        <span class="s">&#39;argmin&#39;</span><span class="p">,</span> <span class="s">&#39;argpartition&#39;</span><span class="p">,</span> <span class="s">&#39;argsort&#39;</span><span class="p">,</span> <span class="s">&#39;around&#39;</span><span class="p">,</span> <span class="s">&#39;choose&#39;</span><span class="p">,</span> <span class="s">&#39;clip&#39;</span><span class="p">,</span>
        <span class="s">&#39;compress&#39;</span><span class="p">,</span> <span class="s">&#39;cumprod&#39;</span><span class="p">,</span> <span class="s">&#39;cumproduct&#39;</span><span class="p">,</span> <span class="s">&#39;cumsum&#39;</span><span class="p">,</span> <span class="s">&#39;diagonal&#39;</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">,</span>
        <span class="s">&#39;ndim&#39;</span><span class="p">,</span> <span class="s">&#39;nonzero&#39;</span><span class="p">,</span> <span class="s">&#39;partition&#39;</span><span class="p">,</span> <span class="s">&#39;prod&#39;</span><span class="p">,</span> <span class="s">&#39;product&#39;</span><span class="p">,</span> <span class="s">&#39;ptp&#39;</span><span class="p">,</span> <span class="s">&#39;put&#39;</span><span class="p">,</span>
        <span class="s">&#39;rank&#39;</span><span class="p">,</span> <span class="s">&#39;ravel&#39;</span><span class="p">,</span> <span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="s">&#39;reshape&#39;</span><span class="p">,</span> <span class="s">&#39;resize&#39;</span><span class="p">,</span> <span class="s">&#39;round_&#39;</span><span class="p">,</span>
        <span class="s">&#39;searchsorted&#39;</span><span class="p">,</span> <span class="s">&#39;shape&#39;</span><span class="p">,</span> <span class="s">&#39;size&#39;</span><span class="p">,</span> <span class="s">&#39;sometrue&#39;</span><span class="p">,</span> <span class="s">&#39;sort&#39;</span><span class="p">,</span> <span class="s">&#39;squeeze&#39;</span><span class="p">,</span>
        <span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="s">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="s">&#39;take&#39;</span><span class="p">,</span> <span class="s">&#39;trace&#39;</span><span class="p">,</span> <span class="s">&#39;transpose&#39;</span><span class="p">,</span> <span class="s">&#39;var&#39;</span><span class="p">,</span>
        <span class="p">]</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">_gentype</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">_gentype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="c"># save away Python sum</span>
<span class="n">_sum_</span> <span class="o">=</span> <span class="nb">sum</span>

<span class="c"># functions that are now methods</span>
<span class="k">def</span> <span class="nf">_wrapit</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">wrap</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__array_wrap__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">wrap</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="take"><a class="viewcode-back" href="../../../index.html#numpy.take">[docs]</a><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take elements from an array along an axis.</span>

<span class="sd">    This function does the same thing as &quot;fancy&quot; indexing (indexing arrays</span>
<span class="sd">    using arrays); however, it can be easier to use if you need elements</span>
<span class="sd">    along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The source array.</span>
<span class="sd">    indices : array_like</span>
<span class="sd">        The indices of the values to extract.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">        Also allow scalars for indices.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis over which to select values. By default, the flattened</span>
<span class="sd">        input array is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        If provided, the result will be placed in this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; -- raise an error (default)</span>
<span class="sd">        * &#39;wrap&#39; -- wrap around</span>
<span class="sd">        * &#39;clip&#39; -- clip to the range</span>

<span class="sd">        &#39;clip&#39; mode means that all indices that are too large are replaced</span>
<span class="sd">        by the index that addresses the last element along that axis. Note</span>
<span class="sd">        that this disables indexing with negative numbers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    subarray : ndarray</span>
<span class="sd">        The returned array has the same type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compress : Take elements using a boolean mask</span>
<span class="sd">    ndarray.take : equivalent method</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = [4, 3, 5, 7, 6, 8]</span>
<span class="sd">    &gt;&gt;&gt; indices = [0, 1, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.take(a, indices)</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    In this example if `a` is an ndarray, &quot;fancy&quot; indexing can be used.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array(a)</span>
<span class="sd">    &gt;&gt;&gt; a[indices]</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    If `indices` is not one dimensional, the output also has these dimensions.</span>

<span class="sd">    &gt;&gt;&gt; np.take(a, [[0, 1], [2, 3]])</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [5, 7]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">take</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">take</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;take&#39;</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>


<span class="c"># not deprecated --- copy if necessary, view otherwise</span></div>
<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../index.html#numpy.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a new shape to an array without changing its data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be reshaped.</span>
<span class="sd">    newshape : int or tuple of ints</span>
<span class="sd">        The new shape should be compatible with the original shape. If</span>
<span class="sd">        an integer, then the result will be a 1-D array of that length.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is inferred</span>
<span class="sd">        from the length of the array and remaining dimensions.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Read the elements of `a` using this index order, and place the elements</span>
<span class="sd">        into the reshaped array using this index order.  &#39;C&#39; means to</span>
<span class="sd">        read / write the elements using C-like index order, with the last axis index</span>
<span class="sd">        changing fastest, back to the first axis index changing slowest.  &#39;F&#39;</span>
<span class="sd">        means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the &#39;C&#39; and &#39;F&#39; options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.  &#39;A&#39;</span>
<span class="sd">        means to read / write the elements in Fortran-like index order if `a` is</span>
<span class="sd">        Fortran *contiguous* in memory, C-like order otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reshaped_array : ndarray</span>
<span class="sd">        This will be a new view object if possible; otherwise, it will</span>
<span class="sd">        be a copy.  Note there is no guarantee of the *memory layout* (C- or</span>
<span class="sd">        Fortran- contiguous) of the returned array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.reshape : Equivalent method.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is not always possible to change the shape of an array without</span>
<span class="sd">    copying the data. If you want an error to be raise if the data is copied,</span>
<span class="sd">    you should assign the new shape to the shape attribute of the array::</span>

<span class="sd">     &gt;&gt;&gt; a = np.zeros((10, 2))</span>
<span class="sd">     # A transpose make the array non-contiguous</span>
<span class="sd">     &gt;&gt;&gt; b = a.T</span>
<span class="sd">     # Taking a view makes it possible to modify the shape without modifying the</span>
<span class="sd">     # initial object.</span>
<span class="sd">     &gt;&gt;&gt; c = b.view()</span>
<span class="sd">     &gt;&gt;&gt; c.shape = (20)</span>
<span class="sd">     AttributeError: incompatible shape for a non-contiguous array</span>

<span class="sd">    The `order` keyword gives the index ordering both for *fetching* the values</span>
<span class="sd">    from `a`, and then *placing* the values into the output array.  For example,</span>
<span class="sd">    let&#39;s say you have an array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    You can think of reshaping as first raveling the array (using the given</span>
<span class="sd">    index order), then inserting the elements from the raveled array into the</span>
<span class="sd">    new array using the same kind of index ordering as was used for the</span>
<span class="sd">    raveling.</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3), order=&#39;F&#39;) # Fortran-like index ordering</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a, order=&#39;F&#39;), (2, 3), order=&#39;F&#39;)</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6, order=&#39;F&#39;)</span>
<span class="sd">    array([1, 4, 2, 5, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reshape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;reshape&#39;</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="choose"><a class="viewcode-back" href="../../../index.html#numpy.choose">[docs]</a><span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array from an index array and a set of arrays to choose from.</span>

<span class="sd">    First of all, if confused or uncertain, definitely look at the Examples -</span>
<span class="sd">    in its full generality, this function is less simple than it might</span>
<span class="sd">    seem from the following code description (below ndi =</span>
<span class="sd">    `numpy.lib.index_tricks`):</span>

<span class="sd">    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.</span>

<span class="sd">    But this omits some subtleties.  Here is a fully general summary:</span>

<span class="sd">    Given an &quot;index&quot; array (`a`) of integers and a sequence of `n` arrays</span>
<span class="sd">    (`choices`), `a` and each choice array are first broadcast, as necessary,</span>
<span class="sd">    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =</span>
<span class="sd">    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``</span>
<span class="sd">    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as</span>
<span class="sd">    follows:</span>

<span class="sd">    * if ``mode=raise`` (the default), then, first of all, each element of</span>
<span class="sd">      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that</span>
<span class="sd">      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position</span>
<span class="sd">      in `Ba` - then the value at the same position in the new array is the</span>
<span class="sd">      value in `Bchoices[i]` at that same position;</span>

<span class="sd">    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)</span>
<span class="sd">      integer; modular arithmetic is used to map integers outside the range</span>
<span class="sd">      `[0, n-1]` back into that range; and then the new array is constructed</span>
<span class="sd">      as above;</span>

<span class="sd">    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)</span>
<span class="sd">      integer; negative integers are mapped to 0; values greater than `n-1`</span>
<span class="sd">      are mapped to `n-1`; and then the new array is constructed as above.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : int array</span>
<span class="sd">        This array must contain integers in `[0, n-1]`, where `n` is the number</span>
<span class="sd">        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any</span>
<span class="sd">        integers are permissible.</span>
<span class="sd">    choices : sequence of arrays</span>
<span class="sd">        Choice arrays. `a` and all of the choices must be broadcastable to the</span>
<span class="sd">        same shape.  If `choices` is itself an array (not recommended), then</span>
<span class="sd">        its outermost dimension (i.e., the one corresponding to</span>
<span class="sd">        ``choices.shape[0]``) is taken as defining the &quot;sequence&quot;.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>
<span class="sd">    mode : {&#39;raise&#39; (default), &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how indices outside `[0, n-1]` will be treated:</span>

<span class="sd">          * &#39;raise&#39; : an exception is raised</span>
<span class="sd">          * &#39;wrap&#39; : value becomes value mod `n`</span>
<span class="sd">          * &#39;clip&#39; : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    merged_array : array</span>
<span class="sd">        The merged result.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError: shape mismatch</span>
<span class="sd">        If `a` and each choice array are not all broadcastable to the same</span>
<span class="sd">        shape.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.choose : equivalent method</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To reduce the chance of misinterpretation, even though the following</span>
<span class="sd">    &quot;abuse&quot; is nominally supported, `choices` should neither be, nor be</span>
<span class="sd">    thought of as, a single array, i.e., the outermost sequence-like container</span>
<span class="sd">    should be either a list or a tuple.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],</span>
<span class="sd">    ...   [20, 21, 22, 23], [30, 31, 32, 33]]</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 3, 1, 0], choices</span>
<span class="sd">    ... # the first element of the result will be the first element of the</span>
<span class="sd">    ... # third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="sd">    ... # will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="sd">    ... # 31, etc.</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;clip&#39;) # 4 goes to 3 (4-1)</span>
<span class="sd">    array([20, 31, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; # because there are 4 choice arrays</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;wrap&#39;) # 4 goes to (4 mod 4)</span>
<span class="sd">    array([20,  1, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; # i.e., 0</span>

<span class="sd">    A couple examples illustrating how choose broadcasts:</span>

<span class="sd">    &gt;&gt;&gt; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; choices = [-10, 10]</span>
<span class="sd">    &gt;&gt;&gt; np.choose(a, choices)</span>
<span class="sd">    array([[ 10, -10,  10],</span>
<span class="sd">           [-10,  10, -10],</span>
<span class="sd">           [ 10, -10,  10]])</span>

<span class="sd">    &gt;&gt;&gt; # With thanks to Anne Archibald</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([0, 1]).reshape((2,1,1))</span>
<span class="sd">    &gt;&gt;&gt; c1 = np.array([1, 2, 3]).reshape((1,3,1))</span>
<span class="sd">    &gt;&gt;&gt; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))</span>
<span class="sd">    &gt;&gt;&gt; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span>
<span class="sd">    array([[[ 1,  1,  1,  1,  1],</span>
<span class="sd">            [ 2,  2,  2,  2,  2],</span>
<span class="sd">            [ 3,  3,  3,  3,  3]],</span>
<span class="sd">           [[-1, -2, -3, -4, -5],</span>
<span class="sd">            [-1, -2, -3, -4, -5],</span>
<span class="sd">            [-1, -2, -3, -4, -5]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">choose</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">choose</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;choose&#39;</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../index.html#numpy.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repeat elements of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    repeats : {int, array of ints}</span>
<span class="sd">        The number of repetitions for each element.  `repeats` is broadcasted</span>
<span class="sd">        to fit the shape of the given axis.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to repeat values.  By default, use the</span>
<span class="sd">        flattened input array, and return a flat output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    repeated_array : ndarray</span>
<span class="sd">        Output array which has the same shape as `a`, except along</span>
<span class="sd">        the given axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    tile : Tile an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 2)</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 3, axis=1)</span>
<span class="sd">    array([[1, 1, 1, 2, 2, 2],</span>
<span class="sd">           [3, 3, 3, 4, 4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">repeat</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="put"><a class="viewcode-back" href="../../../index.html#numpy.put">[docs]</a><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces specified elements of an array with given values.</span>

<span class="sd">    The indexing works on the flattened target array. `put` is roughly</span>
<span class="sd">    equivalent to:</span>

<span class="sd">    ::</span>

<span class="sd">        a.flat[ind] = v</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Target array.</span>
<span class="sd">    ind : array_like</span>
<span class="sd">        Target indices, interpreted as integers.</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Values to place in `a` at target indices. If `v` is shorter than</span>
<span class="sd">        `ind` it will be repeated as necessary.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; -- raise an error (default)</span>
<span class="sd">        * &#39;wrap&#39; -- wrap around</span>
<span class="sd">        * &#39;clip&#39; -- clip to the range</span>

<span class="sd">        &#39;clip&#39; mode means that all indices that are too large are replaced</span>
<span class="sd">        by the index that addresses the last element along that axis. Note</span>
<span class="sd">        that this disables indexing with negative numbers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    putmask, place</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-44,   1, -55,   3,   4])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, 22, -5, mode=&#39;clip&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([ 0,  1,  2,  3, -5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../index.html#numpy.swapaxes">[docs]</a><span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interchange two axes of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis1 : int</span>
<span class="sd">        First axis.</span>
<span class="sd">    axis2 : int</span>
<span class="sd">        Second axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_swapped : ndarray</span>
<span class="sd">        If `a` is an ndarray, then a view of `a` is returned; otherwise</span>
<span class="sd">        a new array is created.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.swapaxes(x,0,1)</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [2],</span>
<span class="sd">           [3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>

<span class="sd">    &gt;&gt;&gt; np.swapaxes(x,0,2)</span>
<span class="sd">    array([[[0, 4],</span>
<span class="sd">            [2, 6]],</span>
<span class="sd">           [[1, 5],</span>
<span class="sd">            [3, 7]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">swapaxes</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="transpose"><a class="viewcode-back" href="../../../index.html#numpy.transpose">[docs]</a><span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permute the dimensions of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axes : list of ints, optional</span>
<span class="sd">        By default, reverse the dimensions, otherwise permute the axes</span>
<span class="sd">        according to the values given.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        `a` with its axes permuted.  A view is returned whenever</span>
<span class="sd">        possible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rollaxis</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    &gt;&gt;&gt; np.transpose(x)</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [1, 3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.ones((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape</span>
<span class="sd">    (2, 1, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">transpose</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;transpose&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="partition"><a class="viewcode-back" href="../../../index.html#numpy.partition">[docs]</a><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;introselect&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a partitioned copy of an array.</span>

<span class="sd">    Creates a copy of the array with its elements rearranged in such a way that</span>
<span class="sd">    the value of the element in kth position is in the position it would be in</span>
<span class="sd">    a sorted array. All elements smaller than the kth element are moved before</span>
<span class="sd">    this element and all equal or greater are moved behind it. The ordering of</span>
<span class="sd">    the elements in the two partitions is undefined.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>
<span class="sd">    kth : int or sequence of ints</span>
<span class="sd">        Element index to partition by. The kth value of the element will be in</span>
<span class="sd">        its final sorted position and all smaller elements will be moved before</span>
<span class="sd">        it and all equal or greater elements behind it.</span>
<span class="sd">        The order all elements in the partitions is undefined.</span>
<span class="sd">        If provided with a sequence of kth it will partition all elements</span>
<span class="sd">        indexed by kth  of them into their sorted position at once.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">        sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">    kind : {&#39;introselect&#39;}, optional</span>
<span class="sd">        Selection algorithm. Default is &#39;introselect&#39;.</span>
<span class="sd">    order : list, optional</span>
<span class="sd">        When `a` is a structured array, this argument specifies which fields</span>
<span class="sd">        to compare first, second, and so on.  This list does not need to</span>
<span class="sd">        include all of the fields.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    partitioned_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.partition : Method to sort an array in-place.</span>
<span class="sd">    argpartition : Indirect partition.</span>
<span class="sd">    sort : Full sorting</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The various selection algorithms are characterized by their average speed,</span>
<span class="sd">    worst case performance, work space size, and whether they are stable. A</span>
<span class="sd">    stable sort keeps items with the same key in the same relative order. The</span>
<span class="sd">    available algorithms have the following properties:</span>

<span class="sd">    ================= ======= ============= ============ =======</span>
<span class="sd">       kind            speed   worst case    work space  stable</span>
<span class="sd">    ================= ======= ============= ============ =======</span>
<span class="sd">    &#39;introselect&#39;        1        O(n)           0         no</span>
<span class="sd">    ================= ======= ============= ============ =======</span>

<span class="sd">    All the partition algorithms make temporary copies of the data when</span>
<span class="sd">    partitioning along any but the last axis.  Consequently, partitioning</span>
<span class="sd">    along the last axis is faster and uses less space than partitioning</span>
<span class="sd">    along any other axis.</span>

<span class="sd">    The sort order for complex numbers is lexicographic. If both the real</span>
<span class="sd">    and imaginary parts are non-nan then the order is determined by the</span>
<span class="sd">    real parts except when they are equal, in which case the order is</span>
<span class="sd">    determined by the imaginary parts.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([3, 4, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.partition(a, 3)</span>
<span class="sd">    array([2, 1, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; np.partition(a, (1, 3))</span>
<span class="sd">    array([1, 2, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&quot;K&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

</div>
<div class="viewcode-block" id="argpartition"><a class="viewcode-back" href="../../../index.html#numpy.argpartition">[docs]</a><span class="k">def</span> <span class="nf">argpartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;introselect&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an indirect partition along the given axis using the algorithm</span>
<span class="sd">    specified by the `kind` keyword. It returns an array of indices of the</span>
<span class="sd">    same shape as `a` that index data along the given axis in partitioned</span>
<span class="sd">    order.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to sort.</span>
<span class="sd">    kth : int or sequence of ints</span>
<span class="sd">        Element index to partition by. The kth element will be in its final</span>
<span class="sd">        sorted position and all smaller elements will be moved before it and</span>
<span class="sd">        all larger elements behind it.</span>
<span class="sd">        The order all elements in the partitions is undefined.</span>
<span class="sd">        If provided with a sequence of kth it will partition all of them into</span>
<span class="sd">        their sorted position at once.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort.  The default is -1 (the last axis). If None,</span>
<span class="sd">        the flattened array is used.</span>
<span class="sd">    kind : {&#39;introselect&#39;}, optional</span>
<span class="sd">        Selection algorithm. Default is &#39;introselect&#39;</span>
<span class="sd">    order : list, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">        which fields to compare first, second, etc.  Not all fields need be</span>
<span class="sd">        specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray, int</span>
<span class="sd">        Array of indices that partition `a` along the specified axis.</span>
<span class="sd">        In other words, ``a[index_array]`` yields a sorted `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    partition : Describes partition algorithms used.</span>
<span class="sd">    ndarray.partition : Inplace partition.</span>
<span class="sd">    argsort : Full indirect sort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See `partition` for notes on the different selection algorithms.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    One dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([3, 4, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; x[np.argpartition(x, 3)]</span>
<span class="sd">    array([2, 1, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x[np.argpartition(x, (1, 3))]</span>
<span class="sd">    array([1, 2, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../index.html#numpy.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sorted copy of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">        sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">        Sorting algorithm. Default is &#39;quicksort&#39;.</span>
<span class="sd">    order : list, optional</span>
<span class="sd">        When `a` is a structured array, this argument specifies which fields</span>
<span class="sd">        to compare first, second, and so on.  This list does not need to</span>
<span class="sd">        include all of the fields.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sorted_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.sort : Method to sort an array in-place.</span>
<span class="sd">    argsort : Indirect sort.</span>
<span class="sd">    lexsort : Indirect stable sort on multiple keys.</span>
<span class="sd">    searchsorted : Find elements in a sorted array.</span>
<span class="sd">    partition : Partial sort.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The various sorting algorithms are characterized by their average speed,</span>
<span class="sd">    worst case performance, work space size, and whether they are stable. A</span>
<span class="sd">    stable sort keeps items with the same key in the same relative</span>
<span class="sd">    order. The three available algorithms have the following</span>
<span class="sd">    properties:</span>

<span class="sd">    =========== ======= ============= ============ =======</span>
<span class="sd">       kind      speed   worst case    work space  stable</span>
<span class="sd">    =========== ======= ============= ============ =======</span>
<span class="sd">    &#39;quicksort&#39;    1     O(n^2)            0          no</span>
<span class="sd">    &#39;mergesort&#39;    2     O(n*log(n))      ~n/2        yes</span>
<span class="sd">    &#39;heapsort&#39;     3     O(n*log(n))       0          no</span>
<span class="sd">    =========== ======= ============= ============ =======</span>

<span class="sd">    All the sort algorithms make temporary copies of the data when</span>
<span class="sd">    sorting along any but the last axis.  Consequently, sorting along</span>
<span class="sd">    the last axis is faster and uses less space than sorting along</span>
<span class="sd">    any other axis.</span>

<span class="sd">    The sort order for complex numbers is lexicographic. If both the real</span>
<span class="sd">    and imaginary parts are non-nan then the order is determined by the</span>
<span class="sd">    real parts except when they are equal, in which case the order is</span>
<span class="sd">    determined by the imaginary parts.</span>

<span class="sd">    Previous to numpy 1.4.0 sorting real and complex arrays containing nan</span>
<span class="sd">    values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan</span>
<span class="sd">    values are sorted to the end. The extended sort order is:</span>

<span class="sd">      * Real: [R, nan]</span>
<span class="sd">      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</span>

<span class="sd">    where R is a non-nan real value. Complex values with the same nan</span>
<span class="sd">    placements are sorted according to the non-nan part if it exists.</span>
<span class="sd">    Non-nan values are sorted as before.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,4],[3,1]])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a)                # sort along the last axis</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array</span>
<span class="sd">    array([1, 1, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    Use the `order` keyword to specify a field to use when sorting a</span>
<span class="sd">    structured array:</span>

<span class="sd">    &gt;&gt;&gt; dtype = [(&#39;name&#39;, &#39;S10&#39;), (&#39;height&#39;, float), (&#39;age&#39;, int)]</span>
<span class="sd">    &gt;&gt;&gt; values = [(&#39;Arthur&#39;, 1.8, 41), (&#39;Lancelot&#39;, 1.9, 38),</span>
<span class="sd">    ...           (&#39;Galahad&#39;, 1.7, 38)]</span>
<span class="sd">    &gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, order=&#39;height&#39;)                        # doctest: +SKIP</span>
<span class="sd">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="sd">           (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="sd">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    Sort by age, then height if ages are equal:</span>

<span class="sd">    &gt;&gt;&gt; np.sort(a, order=[&#39;age&#39;, &#39;height&#39;])               # doctest: +SKIP</span>
<span class="sd">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="sd">           (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="sd">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&quot;K&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

</div>
<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../index.html#numpy.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices that would sort an array.</span>

<span class="sd">    Perform an indirect sort along the given axis using the algorithm specified</span>
<span class="sd">    by the `kind` keyword. It returns an array of indices of the same shape as</span>
<span class="sd">    `a` that index data along the given axis in sorted order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to sort.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort.  The default is -1 (the last axis). If None,</span>
<span class="sd">        the flattened array is used.</span>
<span class="sd">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">        Sorting algorithm.</span>
<span class="sd">    order : list, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">        which fields to compare first, second, etc.  Not all fields need be</span>
<span class="sd">        specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray, int</span>
<span class="sd">        Array of indices that sort `a` along the specified axis.</span>
<span class="sd">        In other words, ``a[index_array]`` yields a sorted `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort : Describes sorting algorithms used.</span>
<span class="sd">    lexsort : Indirect stable sort with multiple keys.</span>
<span class="sd">    ndarray.sort : Inplace sort.</span>
<span class="sd">    argpartition : Indirect partial sort.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See `sort` for notes on the different sorting algorithms.</span>

<span class="sd">    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing</span>
<span class="sd">    nan values. The enhanced sort order is documented in `sort`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    One dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([3, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.argsort(x)</span>
<span class="sd">    array([1, 2, 0])</span>

<span class="sd">    Two-dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 3],</span>
<span class="sd">           [2, 2]])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, axis=0)</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [1, 0]])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, axis=1)</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [0, 1]])</span>

<span class="sd">    Sorting with keys:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([(1, 0), (0, 1)],</span>
<span class="sd">          dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, order=(&#39;x&#39;,&#39;y&#39;))</span>
<span class="sd">    array([1, 0])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, order=(&#39;y&#39;,&#39;x&#39;))</span>
<span class="sd">    array([0, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">argsort</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">argsort</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;argsort&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../index.html#numpy.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indices of the maximum values along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        By default, the index is into the flattened array, otherwise</span>
<span class="sd">        along the specified axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray of ints</span>
<span class="sd">        Array of indices into the array. It has the same shape as `a.shape`</span>
<span class="sd">        with the dimension along `axis` removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.argmax, argmin</span>
<span class="sd">    amax : The maximum value along a given axis.</span>
<span class="sd">    unravel_index : Convert a flat index into an index tuple.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In case of multiple occurrences of the maximum values, the indices</span>
<span class="sd">    corresponding to the first occurrence are returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a, axis=0)</span>
<span class="sd">    array([1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a, axis=1)</span>
<span class="sd">    array([2, 2])</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; b[1] = 5</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([0, 5, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(b) # Only the first occurrence is returned.</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">argmax</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">argmax</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;argmax&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../index.html#numpy.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the minimum values along an axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    argmax : Similar function.  Please refer to `numpy.argmax` for detailed</span>
<span class="sd">        documentation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">argmin</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">argmin</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;argmin&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../index.html#numpy.searchsorted">[docs]</a><span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find indices where elements should be inserted to maintain order.</span>

<span class="sd">    Find the indices into a sorted array `a` such that, if the</span>
<span class="sd">    corresponding elements in `v` were inserted before the indices, the</span>
<span class="sd">    order of `a` would be preserved.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : 1-D array_like</span>
<span class="sd">        Input array. If `sorter` is None, then it must be sorted in</span>
<span class="sd">        ascending order, otherwise `sorter` must be an array of indices</span>
<span class="sd">        that sort it.</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Values to insert into `a`.</span>
<span class="sd">    side : {&#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        If &#39;left&#39;, the index of the first suitable location found is given.</span>
<span class="sd">        If &#39;right&#39;, return the last such index.  If there is no suitable</span>
<span class="sd">        index, return either 0 or N (where N is the length of `a`).</span>
<span class="sd">    sorter : 1-D array_like, optional</span>
<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">        Optional array of integer indices that sort array a into ascending</span>
<span class="sd">        order. They are typically the result of argsort.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : array of ints</span>
<span class="sd">        Array of insertion points with the same shape as `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort : Return a sorted copy of an array.</span>
<span class="sd">    histogram : Produce histogram from 1-D data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Binary search is used to find the required insertion points.</span>

<span class="sd">    As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing</span>
<span class="sd">    `nan` values. The enhanced sort order is documented in `sort`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side=&#39;right&#39;)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])</span>
<span class="sd">    array([0, 5, 1, 2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">searchsorted</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">searchsorted</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;searchsorted&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="resize"><a class="viewcode-back" href="../../../index.html#numpy.resize">[docs]</a><span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with the specified shape.</span>

<span class="sd">    If the new array is larger than the original array, then the new</span>
<span class="sd">    array is filled with repeated copies of `a`.  Note that this behavior</span>
<span class="sd">    is different from a.resize(new_shape) which fills with zeros instead</span>
<span class="sd">    of repeated copies of `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be resized.</span>

<span class="sd">    new_shape : int or tuple of int</span>
<span class="sd">        Shape of resized array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reshaped_array : ndarray</span>
<span class="sd">        The new array is formed from the data in the old array, repeated</span>
<span class="sd">        if necessary to fill out the required number of elements.  The</span>
<span class="sd">        data are repeated in the order that they are stored in memory.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.resize : resize an array in-place.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a=np.array([[0,1],[2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a,(1,4))</span>
<span class="sd">    array([[0, 1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a,(2,4))</span>
<span class="sd">    array([[0, 1, 2, 3],</span>
<span class="sd">           [0, 1, 2, 3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">nt</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_shape</span><span class="p">,)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">Na</span><span class="p">:</span> <span class="k">return</span> <span class="n">mu</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
    <span class="n">total_size</span> <span class="o">=</span> <span class="n">um</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
    <span class="n">n_copies</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_size</span> <span class="o">/</span> <span class="n">Na</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">%</span> <span class="n">Na</span>

    <span class="k">if</span> <span class="n">total_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_copies</span> <span class="o">=</span> <span class="n">n_copies</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">Na</span><span class="o">-</span><span class="n">extra</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span><span class="o">*</span><span class="n">n_copies</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extra</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="n">extra</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../index.html#numpy.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove single-dimensional entries from the shape of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        Selects a subset of the single-dimensional entries in the</span>
<span class="sd">        shape. If an axis is selected with shape entry greater than</span>
<span class="sd">        one, an error is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    squeezed : ndarray</span>
<span class="sd">        The input array, but with all or a subset of the</span>
<span class="sd">        dimensions of length 1 removed. This is always `a` itself</span>
<span class="sd">        or a view into `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[[0], [1], [2]]])</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (1, 3, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x).shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=(2,)).shape</span>
<span class="sd">    (1, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">squeeze</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;squeeze&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># First try to use the new axis= parameter</span>
        <span class="k">return</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c"># For backwards compatibility</span>
        <span class="k">return</span> <span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../index.html#numpy.diagonal">[docs]</a><span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return specified diagonals.</span>

<span class="sd">    If `a` is 2-D, returns the diagonal of `a` with the given offset,</span>
<span class="sd">    i.e., the collection of elements of the form ``a[i, i+offset]``.  If</span>
<span class="sd">    `a` has more than two dimensions, then the axes specified by `axis1`</span>
<span class="sd">    and `axis2` are used to determine the 2-D sub-array whose diagonal is</span>
<span class="sd">    returned.  The shape of the resulting array can be determined by</span>
<span class="sd">    removing `axis1` and `axis2` and appending an index to the right equal</span>
<span class="sd">    to the size of the resulting diagonals.</span>

<span class="sd">    In versions of NumPy prior to 1.7, this function always returned a new,</span>
<span class="sd">    independent array containing a copy of the values in the diagonal.</span>

<span class="sd">    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,</span>
<span class="sd">    but depending on this fact is deprecated. Writing to the resulting</span>
<span class="sd">    array continues to work as it used to, but a FutureWarning is issued.</span>

<span class="sd">    In NumPy 1.9 it returns a read-only view on the original array.</span>
<span class="sd">    Attempting to write to the resulting array will produce an error.</span>

<span class="sd">    In NumPy 1.10, it will return a read/write view, Writing to the returned</span>
<span class="sd">    array will alter your original array.</span>

<span class="sd">    If you don&#39;t write to the array returned by this function, then you can</span>
<span class="sd">    just ignore all of the above.</span>

<span class="sd">    If you depend on the current behavior, then we suggest copying the</span>
<span class="sd">    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead of</span>
<span class="sd">    just ``np.diagonal(a)``. This will work with both past and future versions</span>
<span class="sd">    of NumPy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array from which the diagonals are taken.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset of the diagonal from the main diagonal.  Can be positive or</span>
<span class="sd">        negative.  Defaults to main diagonal (0).</span>
<span class="sd">    axis1 : int, optional</span>
<span class="sd">        Axis to be used as the first axis of the 2-D sub-arrays from which</span>
<span class="sd">        the diagonals should be taken.  Defaults to first axis (0).</span>
<span class="sd">    axis2 : int, optional</span>
<span class="sd">        Axis to be used as the second axis of the 2-D sub-arrays from</span>
<span class="sd">        which the diagonals should be taken. Defaults to second axis (1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_of_diagonals : ndarray</span>
<span class="sd">        If `a` is 2-D, a 1-D array containing the diagonal is returned.</span>
<span class="sd">        If the dimension of `a` is larger, then an array of diagonals is</span>
<span class="sd">        returned, &quot;packed&quot; from left-most dimension to right-most (e.g.,</span>
<span class="sd">        if `a` is 3-D, then the diagonals are &quot;packed&quot; along rows).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dimension of `a` is less than 2.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    diag : MATLAB work-a-like for 1-D and 2-D arrays.</span>
<span class="sd">    diagflat : Create diagonal arrays.</span>
<span class="sd">    trace : Sum along diagonals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape(2,2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal()</span>
<span class="sd">    array([0, 3])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(1)</span>
<span class="sd">    array([1])</span>

<span class="sd">    A 3-D example:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape(2,2,2); a</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(0, # Main diagonals of two arrays created by skipping</span>
<span class="sd">    ...            0, # across the outer(left)-most axis last and</span>
<span class="sd">    ...            1) # the &quot;middle&quot; (row) axis first.</span>
<span class="sd">    array([[0, 6],</span>
<span class="sd">           [1, 7]])</span>

<span class="sd">    The sub-arrays whose main diagonals we just obtained; note that each</span>
<span class="sd">    corresponds to fixing the right-most (column) axis, and that the</span>
<span class="sd">    diagonals are &quot;packed&quot; in rows.</span>

<span class="sd">    &gt;&gt;&gt; a[:,:,0] # main diagonal is [0 6]</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [4, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a[:,:,1] # main diagonal is [1 7]</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [5, 7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../index.html#numpy.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum along diagonals of the array.</span>

<span class="sd">    If `a` is 2-D, the sum along its diagonal with the given offset</span>
<span class="sd">    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.</span>

<span class="sd">    If `a` has more than two dimensions, then the axes specified by axis1 and</span>
<span class="sd">    axis2 are used to determine the 2-D sub-arrays whose traces are returned.</span>
<span class="sd">    The shape of the resulting array is the same as that of `a` with `axis1`</span>
<span class="sd">    and `axis2` removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array, from which the diagonals are taken.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive</span>
<span class="sd">        and negative. Defaults to 0.</span>
<span class="sd">    axis1, axis2 : int, optional</span>
<span class="sd">        Axes to be used as the first and second axis of the 2-D sub-arrays</span>
<span class="sd">        from which the diagonals should be taken. Defaults are the first two</span>
<span class="sd">        axes of `a`.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Determines the data-type of the returned array and of the accumulator</span>
<span class="sd">        where the elements are summed. If dtype has the value None and `a` is</span>
<span class="sd">        of integer type of precision less than the default integer</span>
<span class="sd">        precision, then the default integer precision is used. Otherwise,</span>
<span class="sd">        the precision is the same as that of `a`.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Array into which the output is placed. Its type is preserved and</span>
<span class="sd">        it must be of the right shape to hold the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_along_diagonals : ndarray</span>
<span class="sd">        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has</span>
<span class="sd">        larger dimensions, then an array of sums along diagonals is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    diag, diagonal, diagflat</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.trace(np.eye(3))</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; np.trace(a)</span>
<span class="sd">    array([6, 8])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; np.trace(a).shape</span>
<span class="sd">    (2, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ravel"><a class="viewcode-back" href="../../../index.html#numpy.ravel">[docs]</a><span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a flattened array.</span>

<span class="sd">    A 1-D array, containing the elements of the input, is returned.  A copy is</span>
<span class="sd">    made only if needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.  The elements in `a` are read in the order specified by</span>
<span class="sd">        `order`, and packed as a 1-D array.</span>
<span class="sd">    order : {&#39;C&#39;,&#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        The elements of `a` are read using this index order. &#39;C&#39; means to</span>
<span class="sd">        index the elements in C-like order, with the last axis index changing</span>
<span class="sd">        fastest, back to the first axis index changing slowest.   &#39;F&#39; means to</span>
<span class="sd">        index the elements in Fortran-like index order, with the first index</span>
<span class="sd">        changing fastest, and the last index changing slowest. Note that the &#39;C&#39;</span>
<span class="sd">        and &#39;F&#39; options take no account of the memory layout of the underlying</span>
<span class="sd">        array, and only refer to the order of axis indexing.  &#39;A&#39; means to read</span>
<span class="sd">        the elements in Fortran-like index order if `a` is Fortran *contiguous*</span>
<span class="sd">        in memory, C-like order otherwise.  &#39;K&#39; means to read the elements in</span>
<span class="sd">        the order they occur in memory, except for reversing the data when</span>
<span class="sd">        strides are negative.  By default, &#39;C&#39; index order is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    1d_array : ndarray</span>
<span class="sd">        Output of the same dtype as `a`, and of shape ``(a.size,)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.flat : 1-D iterator over an array.</span>
<span class="sd">    ndarray.flatten : 1-D array copy of the elements of an array</span>
<span class="sd">                      in row-major order.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In C-like (row-major) order, in two dimensions, the row index varies the</span>
<span class="sd">    slowest, and the column index the quickest.  This can be generalized to</span>
<span class="sd">    multiple dimensions, where row-major order implies that the index along the</span>
<span class="sd">    first axis varies slowest, and the index along the last quickest.  The</span>
<span class="sd">    opposite holds for Fortran-like, or column-major, index ordering.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    It is equivalent to ``reshape(-1, order=order)``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; print np.ravel(x)</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    &gt;&gt;&gt; print x.reshape(-1)</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    &gt;&gt;&gt; print np.ravel(x, order=&#39;F&#39;)</span>
<span class="sd">    [1 4 2 5 3 6]</span>

<span class="sd">    When ``order`` is &#39;A&#39;, it will preserve the array&#39;s &#39;C&#39; or &#39;F&#39; ordering:</span>

<span class="sd">    &gt;&gt;&gt; print np.ravel(x.T)</span>
<span class="sd">    [1 4 2 5 3 6]</span>
<span class="sd">    &gt;&gt;&gt; print np.ravel(x.T, order=&#39;A&#39;)</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    When ``order`` is &#39;K&#39;, it will preserve orderings that are neither &#39;C&#39;</span>
<span class="sd">    nor &#39;F&#39;, but won&#39;t reverse axes:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(3)[::-1]; a</span>
<span class="sd">    array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span>
<span class="sd">    array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span>
<span class="sd">    array([2, 1, 0])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a</span>
<span class="sd">    array([[[ 0,  2,  4],</span>
<span class="sd">            [ 1,  3,  5]],</span>
<span class="sd">           [[ 6,  8, 10],</span>
<span class="sd">            [ 7,  9, 11]]])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span>
<span class="sd">    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span>
<span class="sd">    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../index.html#numpy.nonzero">[docs]</a><span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the elements that are non-zero.</span>

<span class="sd">    Returns a tuple of arrays, one for each dimension of `a`, containing</span>
<span class="sd">    the indices of the non-zero elements in that dimension. The</span>
<span class="sd">    corresponding non-zero values can be obtained with::</span>

<span class="sd">        a[nonzero(a)]</span>

<span class="sd">    To group the indices by element, rather than dimension, use::</span>

<span class="sd">        transpose(nonzero(a))</span>

<span class="sd">    The result of this is always a 2-D array, with a row for</span>
<span class="sd">    each non-zero element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple_of_arrays : tuple</span>
<span class="sd">        Indices of elements that are non-zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnonzero :</span>
<span class="sd">        Return indices that are non-zero in the flattened version of the input</span>
<span class="sd">        array.</span>
<span class="sd">    ndarray.nonzero :</span>
<span class="sd">        Equivalent ndarray method.</span>
<span class="sd">    count_nonzero :</span>
<span class="sd">        Counts the number of non-zero elements in the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.eye(3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(x)</span>
<span class="sd">    (array([0, 1, 2]), array([0, 1, 2]))</span>

<span class="sd">    &gt;&gt;&gt; x[np.nonzero(x)]</span>
<span class="sd">    array([ 1.,  1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(np.nonzero(x))</span>
<span class="sd">    array([[0, 0],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [2, 2]])</span>

<span class="sd">    A common use for ``nonzero`` is to find the indices of an array, where</span>
<span class="sd">    a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a</span>
<span class="sd">    boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)</span>
<span class="sd">    yields the indices of the `a` where the condition is true.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6],[7,8,9]])</span>
<span class="sd">    &gt;&gt;&gt; a &gt; 3</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(a &gt; 3)</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    The ``nonzero`` method of the boolean array can also be called.</span>

<span class="sd">    &gt;&gt;&gt; (a &gt; 3).nonzero()</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">nonzero</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;nonzero&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">nonzero</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span>

</div>
<div class="viewcode-block" id="shape"><a class="viewcode-back" href="../../../index.html#numpy.shape">[docs]</a><span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the shape of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shape : tuple of ints</span>
<span class="sd">        The elements of the shape tuple give the lengths of the</span>
<span class="sd">        corresponding array dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    alen</span>
<span class="sd">    ndarray.shape : Equivalent array method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.shape(np.eye(3))</span>
<span class="sd">    (3, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([[1, 2]])</span>
<span class="sd">    (1, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([0])</span>
<span class="sd">    (1,)</span>
<span class="sd">    &gt;&gt;&gt; np.shape(0)</span>
<span class="sd">    ()</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; np.shape(a)</span>
<span class="sd">    (2,)</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (2,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="compress"><a class="viewcode-back" href="../../../index.html#numpy.compress">[docs]</a><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return selected slices of an array along given axis.</span>

<span class="sd">    When working along a given axis, a slice along that axis is returned in</span>
<span class="sd">    `output` for each index where `condition` evaluates to True. When</span>
<span class="sd">    working on a 1-D array, `compress` is equivalent to `extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : 1-D array of bools</span>
<span class="sd">        Array that selects which entries to return. If len(condition)</span>
<span class="sd">        is less than the size of `a` along the given axis, then output is</span>
<span class="sd">        truncated to the length of the condition array.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array from which to extract a part.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to take slices. If None (default), work on the</span>
<span class="sd">        flattened array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Output array.  Its type is preserved and it must be of the right</span>
<span class="sd">        shape to hold the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    compressed_array : ndarray</span>
<span class="sd">        A copy of `a` without the slices along axis for which `condition`</span>
<span class="sd">        is false.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    take, choose, diag, diagonal, select</span>
<span class="sd">    ndarray.compress : Equivalent method in ndarray</span>
<span class="sd">    np.extract: Equivalent method when working on 1-D arrays</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([0, 1], a, axis=0)</span>
<span class="sd">    array([[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True, True], a, axis=0)</span>
<span class="sd">    array([[3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a, axis=1)</span>
<span class="sd">    array([[2],</span>
<span class="sd">           [4],</span>
<span class="sd">           [6]])</span>

<span class="sd">    Working on the flattened array does not return slices along an axis but</span>
<span class="sd">    selects elements.</span>

<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a)</span>
<span class="sd">    array([2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">compress</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">compress</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;compress&#39;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../index.html#numpy.clip">[docs]</a><span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clip (limit) the values in an array.</span>

<span class="sd">    Given an interval, values outside the interval are clipped to</span>
<span class="sd">    the interval edges.  For example, if an interval of ``[0, 1]``</span>
<span class="sd">    is specified, values smaller than 0 become 0, and values larger</span>
<span class="sd">    than 1 become 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing elements to clip.</span>
<span class="sd">    a_min : scalar or array_like</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    a_max : scalar or array_like</span>
<span class="sd">        Maximum value.  If `a_min` or `a_max` are array_like, then they will</span>
<span class="sd">        be broadcasted to the shape of `a`.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        The results will be placed in this array. It may be the input</span>
<span class="sd">        array for in-place clipping.  `out` must be of the right shape</span>
<span class="sd">        to hold the output.  Its type is preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    clipped_array : ndarray</span>
<span class="sd">        An array with the elements of `a`, but where values</span>
<span class="sd">        &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`</span>
<span class="sd">        with `a_max`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, 1, 8)</span>
<span class="sd">    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, 3, 6, out=a)</span>
<span class="sd">    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)</span>
<span class="sd">    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">clip</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;clip&#39;</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clip</span><span class="p">(</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../index.html#numpy.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum of array elements over a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Elements to sum.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a sum is performed.</span>
<span class="sd">        The default (`axis` = `None`) is perform a sum over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a sum is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        The type of the returned array and of the accumulator in which</span>
<span class="sd">        the elements are summed.  By default, the dtype of `a` is used.</span>
<span class="sd">        An exception is when `a` has an integer type with less precision</span>
<span class="sd">        than the default platform integer.  In that case, the default</span>
<span class="sd">        platform integer is used instead.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Array into which the output is placed.  By default, a new array is</span>
<span class="sd">        created.  If `out` is given, it must be of the appropriate shape</span>
<span class="sd">        (the shape of `a` with `axis` removed, i.e.,</span>
<span class="sd">        ``numpy.delete(a.shape, axis)``).  Its type is preserved. See</span>
<span class="sd">        `doc.ufuncs` (Section &quot;Output arguments&quot;) for more details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_along_axis : ndarray</span>
<span class="sd">        An array with the same shape as `a`, with the specified</span>
<span class="sd">        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar</span>
<span class="sd">        is returned.  If an output array is specified, a reference to</span>
<span class="sd">        `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.sum : Equivalent method.</span>

<span class="sd">    cumsum : Cumulative sum of array elements.</span>

<span class="sd">    trapz : Integration of array values using the composite trapezoidal rule.</span>

<span class="sd">    mean, average</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.sum([0.5, 1.5])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]])</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)</span>
<span class="sd">    array([0, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)</span>
<span class="sd">    array([1, 5])</span>

<span class="sd">    If the accumulator is too small, overflow occurs:</span>

<span class="sd">    &gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)</span>
<span class="sd">    -128</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_gentype</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_sum_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="c"># NOTE: Dropping the keepdims parameters here...</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="product"><a class="viewcode-back" href="../../../index.html#numpy.product">[docs]</a><span class="k">def</span> <span class="nf">product</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product of array elements over a given axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    prod : equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">um</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="sometrue"><a class="viewcode-back" href="../../../index.html#numpy.sometrue">[docs]</a><span class="k">def</span> <span class="nf">sometrue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether some values are true.</span>

<span class="sd">    Refer to `any` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    any : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="alltrue"><a class="viewcode-back" href="../../../index.html#numpy.alltrue">[docs]</a><span class="k">def</span> <span class="nf">alltrue</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if all elements of input array are true.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.all : Equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../index.html#numpy.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether any array element along a given axis evaluates to True.</span>

<span class="sd">    Returns single boolean unless `axis` is not ``None``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a logical OR reduction is performed.</span>
<span class="sd">        The default (`axis` = `None`) is to perform a logical OR over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a reduction is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output and its type is preserved</span>
<span class="sd">        (e.g., if it is of type float, then it will remain so, returning</span>
<span class="sd">        1.0 for True and 0.0 for False, regardless of the type of `a`).</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    any : bool or ndarray</span>
<span class="sd">        A new boolean or `ndarray` is returned unless `out` is specified,</span>
<span class="sd">        in which case a reference to `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.any : equivalent method</span>

<span class="sd">    all : Test whether all elements along a given axis evaluate to True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not a Number (NaN), positive infinity and negative infinity evaluate</span>
<span class="sd">    to `True` because these are not equal to zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.any([[True, False], [True, True]])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)</span>
<span class="sd">    array([ True, False], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; np.any([-1, 0, 5])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.any(np.nan)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; o=np.array([False])</span>
<span class="sd">    &gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)</span>
<span class="sd">    &gt;&gt;&gt; z, o</span>
<span class="sd">    (array([ True], dtype=bool), array([ True], dtype=bool))</span>
<span class="sd">    &gt;&gt;&gt; # Check now that z is a reference to o</span>
<span class="sd">    &gt;&gt;&gt; z is o</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; id(z), id(o) # identity of z and o              # doctest: +SKIP</span>
<span class="sd">    (191614240, 191614240)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../index.html#numpy.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether all array elements along a given axis evaluate to True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a logical AND reduction is performed.</span>
<span class="sd">        The default (`axis` = `None`) is to perform a logical AND over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a reduction is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        It must have the same shape as the expected output and its</span>
<span class="sd">        type is preserved (e.g., if ``dtype(out)`` is float, the result</span>
<span class="sd">        will consist of 0.0&#39;s and 1.0&#39;s).  See `doc.ufuncs` (Section</span>
<span class="sd">        &quot;Output arguments&quot;) for more details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all : ndarray, bool</span>
<span class="sd">        A new boolean or array is returned unless `out` is specified,</span>
<span class="sd">        in which case a reference to `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.all : equivalent method</span>

<span class="sd">    any : Test whether any element along a given axis evaluates to True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not a Number (NaN), positive infinity and negative infinity</span>
<span class="sd">    evaluate to `True` because these are not equal to zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.all([[True,False],[True,True]])</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)</span>
<span class="sd">    array([ True, False], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; np.all([-1, 4, 5])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.all([1.0, np.nan])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; o=np.array([False])</span>
<span class="sd">    &gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)</span>
<span class="sd">    &gt;&gt;&gt; id(z), id(o), z                             # doctest: +SKIP</span>
<span class="sd">    (28293632, 28293632, array([ True], dtype=bool))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../index.html#numpy.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative sum of the elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the cumulative sum is computed. The default</span>
<span class="sd">        (None) is to compute the cumsum over the flattened array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  If `dtype` is not specified, it defaults</span>
<span class="sd">        to the dtype of `a`, unless `a` has an integer dtype with a</span>
<span class="sd">        precision less than that of the default platform integer.  In</span>
<span class="sd">        that case, the default platform integer is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output</span>
<span class="sd">        but the type will be cast if necessary. See `doc.ufuncs`</span>
<span class="sd">        (Section &quot;Output arguments&quot;) for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cumsum_along_axis : ndarray.</span>
<span class="sd">        A new array holding the result is returned unless `out` is</span>
<span class="sd">        specified, in which case a reference to `out` is returned. The</span>
<span class="sd">        result has the same size as `a`, and the same shape as `a` if</span>
<span class="sd">        `axis` is not None or `a` is a 1-d array.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sum : Sum array elements.</span>

<span class="sd">    trapz : Integration of array values using the composite trapezoidal rule.</span>

<span class="sd">    diff :  Calculate the n-th order discrete difference along given axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a)</span>
<span class="sd">    array([ 1,  3,  6, 10, 15, 21])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)</span>
<span class="sd">    array([  1.,   3.,   6.,  10.,  15.,  21.])</span>

<span class="sd">    &gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [5, 7, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows</span>
<span class="sd">    array([[ 1,  3,  6],</span>
<span class="sd">           [ 4,  9, 15]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cumsum</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;cumsum&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="cumproduct"><a class="viewcode-back" href="../../../index.html#numpy.cumproduct">[docs]</a><span class="k">def</span> <span class="nf">cumproduct</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative product over the given axis.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cumprod : equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cumprod</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cumprod</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;cumprod&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ptp"><a class="viewcode-back" href="../../../index.html#numpy.ptp">[docs]</a><span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Range of values (maximum - minimum) along an axis.</span>

<span class="sd">    The name of the function comes from the acronym for &#39;peak to peak&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input values.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to find the peaks.  By default, flatten the</span>
<span class="sd">        array.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type of the output values will be cast if necessary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ptp : ndarray</span>
<span class="sd">        A new array holding the result, unless `out` was</span>
<span class="sd">        specified, in which case a reference to `out` is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    &gt;&gt;&gt; np.ptp(x, axis=0)</span>
<span class="sd">    array([2, 2])</span>

<span class="sd">    &gt;&gt;&gt; np.ptp(x, axis=1)</span>
<span class="sd">    array([1, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ptp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ptp</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;ptp&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="amax"><a class="viewcode-back" href="../../../index.html#numpy.amax">[docs]</a><span class="k">def</span> <span class="nf">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the maximum of an array or maximum along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to operate.  By default, flattened input is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result.  Must</span>
<span class="sd">        be of the same shape and buffer length as the expected output.</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for more details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amax : ndarray or scalar</span>
<span class="sd">        Maximum of `a`. If `axis` is None, the result is a scalar value.</span>
<span class="sd">        If `axis` is given, the result is an array of dimension</span>
<span class="sd">        ``a.ndim - 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagating any NaNs.</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignoring any NaNs.</span>
<span class="sd">    argmax :</span>
<span class="sd">        Return the indices of the maximum values.</span>

<span class="sd">    nanmin, minimum, fmin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NaN values are propagated, that is if at least one item is NaN, the</span>
<span class="sd">    corresponding max value will be NaN as well. To ignore NaN values</span>
<span class="sd">    (MATLAB behavior), please use nanmax.</span>

<span class="sd">    Don&#39;t use `amax` for element-wise comparison of 2 arrays; when</span>
<span class="sd">    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than</span>
<span class="sd">    ``amax(a, axis=0)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis</span>
<span class="sd">    array([2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis</span>
<span class="sd">    array([1, 3])</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(5, dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; b[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; np.amax(b)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax(b)</span>
<span class="sd">    4.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amax</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="c"># NOTE: Dropping the keepdims parameter</span>
        <span class="k">return</span> <span class="n">amax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="amin"><a class="viewcode-back" href="../../../index.html#numpy.amin">[docs]</a><span class="k">def</span> <span class="nf">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum of an array or minimum along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to operate.  By default, flattened input is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result.  Must</span>
<span class="sd">        be of the same shape and buffer length as the expected output.</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for more details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amin : ndarray or scalar</span>
<span class="sd">        Minimum of `a`. If `axis` is None, the result is a scalar value.</span>
<span class="sd">        If `axis` is given, the result is an array of dimension</span>
<span class="sd">        ``a.ndim - 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagating any NaNs.</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignoring any NaNs.</span>
<span class="sd">    argmin :</span>
<span class="sd">        Return the indices of the minimum values.</span>

<span class="sd">    nanmax, maximum, fmax</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NaN values are propagated, that is if at least one item is NaN, the</span>
<span class="sd">    corresponding min value will be NaN as well. To ignore NaN values</span>
<span class="sd">    (MATLAB behavior), please use nanmin.</span>

<span class="sd">    Don&#39;t use `amin` for element-wise comparison of 2 arrays; when</span>
<span class="sd">    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than</span>
<span class="sd">    ``amin(a, axis=0)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis</span>
<span class="sd">    array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis</span>
<span class="sd">    array([0, 2])</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(5, dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; b[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; np.amin(b)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin(b)</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amin</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="c"># NOTE: Dropping the keepdims parameter</span>
        <span class="k">return</span> <span class="n">amin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="alen"><a class="viewcode-back" href="../../../index.html#numpy.alen">[docs]</a><span class="k">def</span> <span class="nf">alen</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the length of the first dimension of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">       Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alen : int</span>
<span class="sd">       Length of the first dimension of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    shape, size</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,4,5))</span>
<span class="sd">    &gt;&gt;&gt; a.shape[0]</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; np.alen(a)</span>
<span class="sd">    7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../../../index.html#numpy.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product of array elements over a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a product is performed.</span>
<span class="sd">        The default (`axis` = `None`) is perform a product over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a product is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The data-type of the returned array, as well as of the accumulator</span>
<span class="sd">        in which the elements are multiplied.  By default, if `a` is of</span>
<span class="sd">        integer type, `dtype` is the default platform integer. (Note: if</span>
<span class="sd">        the type of `a` is unsigned, then so is `dtype`.)  Otherwise,</span>
<span class="sd">        the dtype is the same as that of `a`.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output, but the type of the</span>
<span class="sd">        output values will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    product_along_axis : ndarray, see `dtype` parameter above.</span>
<span class="sd">        An array shaped as `a` but with the specified axis removed.</span>
<span class="sd">        Returns a reference to `out` if specified.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.prod : equivalent method</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.  That means that, on a 32-bit platform:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x) #random</span>
<span class="sd">    16</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By default, calculate the product of all elements:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([1.,2.])</span>
<span class="sd">    2.0</span>

<span class="sd">    Even when the input array is two-dimensional:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])</span>
<span class="sd">    24.0</span>

<span class="sd">    But we can also specify the axis over which to multiply:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)</span>
<span class="sd">    array([  2.,  12.])</span>

<span class="sd">    If the type of `x` is unsigned, then the output type is</span>
<span class="sd">    the unsigned platform integer:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x).dtype == np.uint</span>
<span class="sd">    True</span>

<span class="sd">    If `x` is of a signed integer type, then the output type</span>
<span class="sd">    is the default platform integer:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x).dtype == np.int</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">prod</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../index.html#numpy.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative product of elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the cumulative product is computed.  By default</span>
<span class="sd">        the input is flattened.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type of the returned array, as well as of the accumulator in which</span>
<span class="sd">        the elements are multiplied.  If *dtype* is not specified, it</span>
<span class="sd">        defaults to the dtype of `a`, unless `a` has an integer dtype with</span>
<span class="sd">        a precision less than that of the default platform integer.  In</span>
<span class="sd">        that case, the default platform integer is used instead.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output</span>
<span class="sd">        but the type of the resulting values will be cast if necessary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cumprod : ndarray</span>
<span class="sd">        A new array holding the result is returned unless `out` is</span>
<span class="sd">        specified, in which case a reference to out is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2</span>
<span class="sd">    ...               # total product 1*2*3 = 6</span>
<span class="sd">    array([1, 2, 6])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output</span>
<span class="sd">    array([   1.,    2.,    6.,   24.,  120.,  720.])</span>

<span class="sd">    The cumulative product for each column (i.e., over the rows) of `a`:</span>

<span class="sd">    &gt;&gt;&gt; np.cumprod(a, axis=0)</span>
<span class="sd">    array([[ 1,  2,  3],</span>
<span class="sd">           [ 4, 10, 18]])</span>

<span class="sd">    The cumulative product for each row (i.e. over the columns) of `a`:</span>

<span class="sd">    &gt;&gt;&gt; np.cumprod(a,axis=1)</span>
<span class="sd">    array([[  1,   2,   6],</span>
<span class="sd">           [  4,  20, 120]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cumprod</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cumprod</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;cumprod&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ndim"><a class="viewcode-back" href="../../../index.html#numpy.ndim">[docs]</a><span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of dimensions of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.  If it is not already an ndarray, a conversion is</span>
<span class="sd">        attempted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number_of_dimensions : int</span>
<span class="sd">        The number of dimensions in `a`.  Scalars are zero-dimensional.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.ndim : equivalent method</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ndim([[1,2,3],[4,5,6]])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(np.array([[1,2,3],[4,5,6]]))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(1)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span>

</div>
<div class="viewcode-block" id="rank"><a class="viewcode-back" href="../../../index.html#numpy.rank">[docs]</a><span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of dimensions of an array.</span>

<span class="sd">    If `a` is not already an array, a conversion is attempted.</span>
<span class="sd">    Scalars are zero dimensional.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is deprecated in NumPy 1.9 to avoid confusion with</span>
<span class="sd">        `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function</span>
<span class="sd">        should be used instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array whose number of dimensions is desired. If `a` is not an array,</span>
<span class="sd">        a conversion is attempted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number_of_dimensions : int</span>
<span class="sd">        The number of dimensions in the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndim : equivalent function</span>
<span class="sd">    ndarray.ndim : equivalent property</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the old Numeric package, `rank` was the term used for the number of</span>
<span class="sd">    dimensions, but in Numpy `ndim` is used instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.rank([1,2,3])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.rank(np.array([[1,2,3],[4,5,6]]))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.rank(1)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s">&quot;`rank` is deprecated; use the `ndim` attribute or function instead. &quot;</span>
        <span class="s">&quot;To find the rank of a matrix see `numpy.linalg.matrix_rank`.&quot;</span><span class="p">,</span>
        <span class="n">VisibleDeprecationWarning</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span>

</div>
<div class="viewcode-block" id="size"><a class="viewcode-back" href="../../../index.html#numpy.size">[docs]</a><span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the elements are counted.  By default, give</span>
<span class="sd">        the total number of elements.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    element_count : int</span>
<span class="sd">        Number of elements along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>
<span class="sd">    ndarray.size : number of elements in array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; np.size(a)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; np.size(a,1)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.size(a,0)</span>
<span class="sd">    2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="around"><a class="viewcode-back" href="../../../index.html#numpy.around">[docs]</a><span class="k">def</span> <span class="nf">around</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evenly round to the given number of decimals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    decimals : int, optional</span>
<span class="sd">        Number of decimal places to round to (default: 0).  If</span>
<span class="sd">        decimals is negative, it specifies the number of positions to</span>
<span class="sd">        the left of the decimal point.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output, but the type of the output</span>
<span class="sd">        values will be cast if necessary. See `doc.ufuncs` (Section</span>
<span class="sd">        &quot;Output arguments&quot;) for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rounded_array : ndarray</span>
<span class="sd">        An array of the same type as `a`, containing the rounded values.</span>
<span class="sd">        Unless `out` was specified, a new array is created.  A reference to</span>
<span class="sd">        the result is returned.</span>

<span class="sd">        The real and imaginary parts of complex numbers are rounded</span>
<span class="sd">        separately.  The result of rounding a float is a float.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.round : equivalent method</span>

<span class="sd">    ceil, fix, floor, rint, trunc</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For values exactly halfway between rounded decimal values, Numpy</span>
<span class="sd">    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,</span>
<span class="sd">    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due</span>
<span class="sd">    to the inexact representation of decimal fractions in the IEEE</span>
<span class="sd">    floating point standard [1]_ and errors introduced when scaling</span>
<span class="sd">    by powers of ten.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] &quot;Lecture Notes on the Status of  IEEE 754&quot;, William Kahan,</span>
<span class="sd">           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</span>
<span class="sd">    .. [2] &quot;How Futile are Mindless Assessments of</span>
<span class="sd">           Roundoff in Floating-Point Computation?&quot;, William Kahan,</span>
<span class="sd">           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.around([0.37, 1.64])</span>
<span class="sd">    array([ 0.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)</span>
<span class="sd">    array([ 0.4,  1.6])</span>
<span class="sd">    &gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value</span>
<span class="sd">    array([ 0.,  2.,  2.,  4.,  4.])</span>
<span class="sd">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned</span>
<span class="sd">    array([ 1,  2,  3, 11])</span>
<span class="sd">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)</span>
<span class="sd">    array([ 0,  0,  0, 10])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">round</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">round</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;round&#39;</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="round_"><a class="viewcode-back" href="../../../index.html#numpy.round_">[docs]</a><span class="k">def</span> <span class="nf">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round an array to the given number of decimals.</span>

<span class="sd">    Refer to `around` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    around : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">round</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">round</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;round&#39;</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../index.html#numpy.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the arithmetic mean along the specified axis.</span>

<span class="sd">    Returns the average of the array elements.  The average is taken over</span>
<span class="sd">    the flattened array by default, otherwise over the specified axis.</span>
<span class="sd">    `float64` intermediate and return values are used for integer inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the means are computed. The default is to compute</span>
<span class="sd">        the mean of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the mean.  For integer inputs, the default</span>
<span class="sd">        is `float64`; for floating point inputs, it is the same as the</span>
<span class="sd">        input dtype.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">        See `doc.ufuncs` for details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : ndarray, see dtype parameter above</span>
<span class="sd">        If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">        otherwise a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    average : Weighted average</span>
<span class="sd">    std, var, nanmean, nanstd, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arithmetic mean is the sum of the elements along the axis divided</span>
<span class="sd">    by the number of elements.</span>

<span class="sd">    Note that for floating-point input, the mean is computed using the</span>
<span class="sd">    same precision the input has.  Depending on the input data, this can</span>
<span class="sd">    cause the results to be inaccurate, especially for `float32` (see</span>
<span class="sd">    example below).  Specifying a higher-precision accumulator using the</span>
<span class="sd">    `dtype` keyword can alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a, axis=0)</span>
<span class="sd">    array([ 2.,  3.])</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a, axis=1)</span>
<span class="sd">    array([ 1.5,  3.5])</span>

<span class="sd">    In single precision, `mean` can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0, :] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1, :] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a)</span>
<span class="sd">    0.546875</span>

<span class="sd">    Computing the mean in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.mean(a, dtype=np.float64)</span>
<span class="sd">    0.55000000074505806</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span>
            <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../index.html#numpy.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the standard deviation along the specified axis.</span>

<span class="sd">    Returns the standard deviation, a measure of the spread of a distribution,</span>
<span class="sd">    of the array elements. The standard deviation is computed for the</span>
<span class="sd">    flattened array by default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Calculate the standard deviation of these values.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the standard deviation is computed. The default is</span>
<span class="sd">        to compute the standard deviation of the flattened array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type to use in computing the standard deviation. For arrays of</span>
<span class="sd">        integer type the default is float64, for arrays of float types it is</span>
<span class="sd">        the same as the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output but the type (of the calculated</span>
<span class="sd">        values) will be cast if necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        Means Delta Degrees of Freedom.  The divisor used in calculations</span>
<span class="sd">        is ``N - ddof``, where ``N`` represents the number of elements.</span>
<span class="sd">        By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_deviation : ndarray, see dtype parameter above.</span>
<span class="sd">        If `out` is None, return a new array containing the standard deviation,</span>
<span class="sd">        otherwise return a reference to the output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    var, mean, nanmean, nanstd, nanvar</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The standard deviation is the square root of the average of the squared</span>
<span class="sd">    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.</span>

<span class="sd">    The average squared deviation is normally calculated as</span>
<span class="sd">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,</span>
<span class="sd">    the divisor ``N - ddof`` is used instead. In standard statistical</span>
<span class="sd">    practice, ``ddof=1`` provides an unbiased estimator of the variance</span>
<span class="sd">    of the infinite population. ``ddof=0`` provides a maximum likelihood</span>
<span class="sd">    estimate of the variance for normally distributed variables. The</span>
<span class="sd">    standard deviation computed in this function is the square root of</span>
<span class="sd">    the estimated variance, so even with ``ddof=1``, it will not be an</span>
<span class="sd">    unbiased estimate of the standard deviation per se.</span>

<span class="sd">    Note that, for complex numbers, `std` takes the absolute</span>
<span class="sd">    value before squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the *std* is computed using the same</span>
<span class="sd">    precision the input has. Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for float32 (see example below).</span>
<span class="sd">    Specifying a higher-accuracy accumulator using the `dtype` keyword can</span>
<span class="sd">    alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.std(a)</span>
<span class="sd">    1.1180339887498949</span>
<span class="sd">    &gt;&gt;&gt; np.std(a, axis=0)</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.std(a, axis=1)</span>
<span class="sd">    array([ 0.5,  0.5])</span>

<span class="sd">    In single precision, std() can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2,512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0,:] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1,:] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.std(a)</span>
<span class="sd">    0.45172946707416706</span>

<span class="sd">    Computing the standard deviation in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.std(a, dtype=np.float64)</span>
<span class="sd">    0.44999999925552653</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">std</span>
            <span class="k">return</span> <span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                                <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../index.html#numpy.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the variance along the specified axis.</span>

<span class="sd">    Returns the variance of the array elements, a measure of the spread of a</span>
<span class="sd">    distribution.  The variance is computed for the flattened array by</span>
<span class="sd">    default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose variance is desired.  If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the variance is computed.  The default is to compute</span>
<span class="sd">        the variance of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the variance.  For arrays of integer type</span>
<span class="sd">        the default is `float32`; for arrays of float types it is the same as</span>
<span class="sd">        the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output, but the type is cast if</span>
<span class="sd">        necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">        ``N - ddof``, where ``N`` represents the number of elements. By</span>
<span class="sd">        default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variance : ndarray, see dtype parameter above</span>
<span class="sd">        If ``out=None``, returns a new array containing the variance;</span>
<span class="sd">        otherwise, a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    std , mean, nanmean, nanstd, nanvar</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The variance is the average of the squared deviations from the mean,</span>
<span class="sd">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span>

<span class="sd">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span>
<span class="sd">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span>
<span class="sd">    instead.  In standard statistical practice, ``ddof=1`` provides an</span>
<span class="sd">    unbiased estimator of the variance of a hypothetical infinite population.</span>
<span class="sd">    ``ddof=0`` provides a maximum likelihood estimate of the variance for</span>
<span class="sd">    normally distributed variables.</span>

<span class="sd">    Note that for complex numbers, the absolute value is taken before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the variance is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32` (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; np.var(a)</span>
<span class="sd">    1.25</span>
<span class="sd">    &gt;&gt;&gt; np.var(a, axis=0)</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.var(a, axis=1)</span>
<span class="sd">    array([ 0.25,  0.25])</span>

<span class="sd">    In single precision, var() can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2,512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0,:] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1,:] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.var(a)</span>
<span class="sd">    0.20405951142311096</span>

<span class="sd">    Computing the variance in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.var(a, dtype=np.float64)</span>
<span class="sd">    0.20249999932997387</span>
<span class="sd">    &gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2</span>
<span class="sd">    0.20250000000000001</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">var</span>
            <span class="k">return</span> <span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                                <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Rich Adams.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.4</a>
      
    </div>

    

    
  </body>
</html>